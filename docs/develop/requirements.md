# Requirements Definition - MIP Solver API

## 1. Objective

To create a robust HTTP server using FastAPI that solves Mixed-Integer Programming (MIP) problems. The server will provide an API for users to submit problems, receive solutions, and monitor the solving process in real-time.

## 2. Functional Requirements

### 2.1 Core Features

- [ ] **Problem Submission Endpoint:** Implement an HTTP POST endpoint (e.g., `/solve`) that accepts and solves MIP problems.
- [ ] **JSON Input Format:** The endpoint must accept `application/json` for submitting the problem. **This JSON format must be compatible with the structure generated by the `to_dict()` method of a PuLP `LpProblem` object.**
- [ ] **Real-time Log Streaming:** Implement an endpoint (e.g., `/solve-stream`) that provides real-time streaming of the solver's log output to the client, allowing users to monitor the progress of long-running tasks.
- [ ] **JSON Result Output:** The final solution (including variable values, objective function value, and solver status) must be returned in a well-defined JSON format.
- [ ] **Solver Information Endpoint:** Create an endpoint that returns information about the available MIP solver and its configuration.
- [ ] **Error Handling:** The API must handle invalid inputs, solver errors, and other potential issues gracefully, returning appropriate HTTP status codes and error messages.

### 2.2 Python Client Library (PuLP Integration)

- [ ] **Create a Python Package:** Develop a distributable Python client library to interact with the MIP Solver API.
- [ ] **PuLP Solver Interface:** The library must implement a class that conforms to the PuLP solver interface (e.g., by inheriting from `pulp.LpSolver`).
- [ ] **API Interaction:** This custom solver class will not solve problems locally. Instead, it will:
  - Serialize the PuLP problem instance into the JSON format required by the API.
  - Send the problem to the API's `/solve` endpoint via an HTTP POST request.
  - Receive the JSON solution from the API.
  - Parse the solution and update the PuLP problem object with the results (variable values, objective value, status).
- [ ] **Log Streaming:** The client should be able to connect to the `/solve-stream` endpoint to display the solver logs in the user's console in real-time.

### 2.3 Optional Features

- [ ] **Support for Additional File Formats:** Extend the API to accept other common optimization file formats, such as LP.
- [ ] **Asynchronous Solving:** For very large problems, implement a task queue system where a problem is submitted, a task ID is returned, and the user can query the status/result later.

## 3. Non-Functional Requirements

### 3.1 Performance

- **Responsiveness:** The API endpoints should respond quickly. The overhead introduced by the API server should be negligible compared to the time the MIP solver takes.
- **Concurrency:** The server must be able to handle multiple problem-solving requests concurrently without blocking.
- **Low-Latency Streaming:** The log streaming endpoint should deliver log messages to the client with minimal delay.

### 3.2 Security

- **Input Validation:** Rigorously validate all user inputs, including file uploads and JSON payloads, to prevent parsing errors and potential security vulnerabilities.
- **Resource Limiting:** Implement limits on the maximum size of input files and JSON bodies to protect against Denial-of-Service (DoS) attacks.

### 3.3 Maintainability

- **Typed Codebase:** Adhere to Python type hinting for all code, leveraging FastAPI's type-driven features.
- **Modular Design:** Structure the application with a clear separation of concerns: API interface, problem-solving logic, and data models.
- **Configuration Management:** Externalize configuration (e.g., solver settings, resource limits) from the code.

### 3.4 Compatibility

- **Standard HTTP:** The API must be callable from any standard HTTP client.
- **Defined JSON Schema:** The structure for JSON inputs and outputs should be clearly defined and documented, potentially using JSON Schema.

## 4. Constraints

### 4.1 Technical Constraints

- **Framework:** The web server must be implemented using the FastAPI framework.
- **Default Solver:** The SCIP solver must be supported and configured as the default solver.
- **Output Format:** The final result of a solved problem must be returned as JSON.

### 4.2 Business Constraints

- None specified at this time.

## 5. Success Criteria

### 5.1 Definition of Done

- [ ] An endpoint is implemented that successfully solves MIP problems submitted as both MPS files and JSON objects.
- [ ] A separate endpoint streams solver logs in real-time.
- [ ] The solution is returned in a valid and documented JSON format.
- [ ] The system handles invalid inputs and solver errors gracefully.
- [ ] A Python client library is created that integrates with PuLP as a custom solver and uses the API.
- [ ] The implementation is covered by a comprehensive suite of unit and integration tests for both the server and the client library.

### 5.2 Acceptance Criteria

- A user can successfully submit a valid MIP problem (as both a file and JSON) and receive a correct, machine-readable JSON solution.
- A user can connect to the streaming endpoint with an HTTP client and observe the solver's log messages as they are generated during the solving process.

## 6. Potential Risks

- **Solver Complexity:** The chosen MIP solver library may have licensing restrictions or deployment complexities that need to be addressed.
- **Streaming Implementation:** Implementing a robust, concurrent streaming mechanism can be challenging and may require careful handling of connections and resources.
- **Resource Consumption:** Large or complex MIP problems can consume significant CPU and memory, potentially impacting server stability if not managed properly.

## 7. Future Considerations

- **Specific MIP Solver:** The specific Python MIP solver library (e.g., Google OR-Tools, PuLP, Gurobipy, SCIP) needs to be selected. This choice will be finalized in the design phase.
- **Data Models:** The exact JSON schema for the dictionary-based problem submission and the JSON result output must be designed.
- **Streaming Technology:** The underlying technology for streaming (e.g., Server-Sent Events, WebSockets) needs to be chosen. Server-Sent Events (SSE) are a strong candidate.
